<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>LeseSpa√ü Word Lab (Loop-Pausing Fix)</title>
  <style>
    :root {
      --bg: #0d1117; --ink: #e6ebf2; --ink-dim: #AFB6C3; --accent: #10b981; --accent-2: #34d399; --success: #22c55e;
    }
    html, body { margin: 0; height: 100%; background: var(--bg); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; color: var(--ink); }
    canvas { display: block; width: 100vw; height: 100vh; touch-action: none; }
  </style>
</head>
<body>
<canvas id="app"></canvas>

<script>
/* ===========================================================
   LeseSpa√ü Deutsch ‚Äî FINAL TEST (WORD LAB w/ LOOP-PAUSING)
   =========================================================== */

/* ---------- Canvas, Globals, Input ---------- */
const canvas = document.getElementById('app');
const ctx = canvas.getContext('2d');
let DPR = Math.max(1, Math.min(2.5, window.devicePixelRatio || 1));
let activeScene = null;
let pointer={x:0,y:0,down:false};
let animationFrameId = null; // This will hold the ID of our loop

/* ---------- Loop Control Functions ---------- */
function resumeLoop() {
    if (animationFrameId) return; // Prevent multiple loops
    console.log("Resuming render loop.");
    animationFrameId = requestAnimationFrame(loop);
}
function pauseLoop() {
    if (!animationFrameId) return;
    cancelAnimationFrame(animationFrameId);
    animationFrameId = null;
    console.log("Render loop PAUSED to allow TTS to work.");
}

/* ---------- Speech Engine (with loop control built-in) ---------- */
let voiceDE = null;
let voicesReady = false;

async function initializeSpeech() { /* ... same as before ... */ return new Promise(async (resolve) => { if (!('speechSynthesis' in window)) { console.error("TTS not supported"); return resolve(); } const voices = await new Promise(res => { const get = () => { const v = speechSynthesis.getVoices(); if (v.length) res(v); }; speechSynthesis.onvoiceschanged = get; get(); }); const deVoices = voices.filter(v => v.lang.startsWith('de')); if (deVoices.length > 0) { voiceDE = deVoices.find(v => v.name.includes('Anna')) || deVoices.find(v => v.localService) || deVoices[0]; } voicesReady = true; resolve(); }); }

function speak(text, options = {}) {
  if (!voicesReady || !voiceDE) {
    console.error('Speak called but engine is not ready.');
    return;
  }
  
  // 1. Pause the loop immediately. This is the critical step.
  pauseLoop();

  // 2. We will NOT trust onend. We create our own timer to resume the loop.
  // This prevents the app from freezing if the TTS fails silently.
  setTimeout(resumeLoop, 1500); // Resume after 1.5 seconds, regardless.

  try {
    speechSynthesis.cancel();
    const utterance = new SpeechSynthesisUtterance(text);
    utterance.voice = voiceDE;
    utterance.lang = voiceDE.lang;
    utterance.rate = options.rate || 0.85;
    
    // We can still listen for the event for logging purposes.
    utterance.onstart = () => console.log(`SUCCESS! TTS started for: "${text}"`);
    utterance.onerror = (e) => console.error(`TTS utterance error: ${e.error}`);

    speechSynthesis.speak(utterance);
  } catch (e) {
    console.error("Speech Synthesis Error:", e);
    resumeLoop(); // If the call itself fails, resume immediately.
  }
}

/* ---------- Data, UI, and other helpers (all unchanged) ---------- */
function resize(){ DPR = Math.max(1, Math.min(2.5, window.devicePixelRatio || 1)); canvas.width = Math.floor(window.innerWidth * DPR); canvas.height = Math.floor(window.innerHeight * DPR); ctx.setTransform(DPR,0,0,DPR,0,0); activeScene?.layout?.(); }
window.addEventListener('resize', resize);
function rrect(x,y,w,h,r){ const rr = Math.min(r, Math.min(w,h)/2); ctx.beginPath(); ctx.moveTo(x+rr,y); ctx.arcTo(x+w,y,x+w,y+h,rr); ctx.arcTo(x+w,y+h,x,y+h,rr); ctx.arcTo(x,y+h,x,y,rr); ctx.arcTo(x,y,x+w,y,rr); ctx.closePath(); }
function gradient(x,y,w,h,c1,c2){ const g = ctx.createLinearGradient(x,y,x+w,y+h); g.addColorStop(0,c1); g.addColorStop(1,c2); return g; }
function shadow(fn){ ctx.save(); ctx.shadowColor='rgba(0,0,0,0.45)'; ctx.shadowBlur=18; ctx.shadowOffsetY=8; fn(); ctx.restore(); }
class Button { constructor(label, emoji, x,y,w,h, onClick){ this.label=label; this.emoji=emoji; this.x=x; this.y=y; this.w=w; this.h=h; this.onClick=onClick; this.hover=false; } contains(px,py){ return px>=this.x && py>=this.y && px<=this.x+this.w && py<=this.y+this.h; } draw(){ const c1=getComputedStyle(document.documentElement).getPropertyValue('--accent').trim(); const c2=getComputedStyle(document.documentElement).getPropertyValue('--accent-2').trim(); shadow(()=>{ ctx.fillStyle=gradient(this.x,this.y,this.w,this.h,this.hover?c2:c1,this.hover?c1:c2); rrect(this.x,this.y,this.w,this.h,20); ctx.fill(); }); ctx.fillStyle='rgba(255,255,255,0.95)'; ctx.font='20px system-ui'; const txt=`${this.emoji?this.emoji+'  ':''}${this.label}`; const tw=ctx.measureText(txt).width; ctx.fillText(txt, this.x+(this.w-tw)/2, this.y+this.h/2+6); } }
function strokeRRect(x,y,w,h,r,lineWidth=2,color='rgba(255,255,255,0.35)',dash=[6,6]){ const rr=Math.min(r,Math.min(w,h)/2); ctx.save(); ctx.beginPath(); ctx.moveTo(x+rr,y); ctx.arcTo(x+w,y,x+w,y+h,rr); ctx.arcTo(x+w,y+h,x,y+h,rr); ctx.arcTo(x,y+h,x,y,rr); ctx.arcTo(x,y,x+w,y,rr); ctx.closePath(); ctx.lineWidth=lineWidth; ctx.setLineDash(dash); ctx.strokeStyle=color; ctx.stroke(); ctx.restore(); }
canvas.addEventListener('pointerdown',e=>{ try { speechSynthesis.speak(new SpeechSynthesisUtterance('')); } catch(e){} const rect=canvas.getBoundingClientRect(); pointer.x=(e.clientX-rect.left); pointer.y=(e.clientY-rect.top); pointer.down=true; activeScene?.onPointer('down', pointer); });
canvas.addEventListener('pointermove',e=>{ const rect=canvas.getBoundingClientRect(); pointer.x=(e.clientX-rect.left); pointer.y=(e.clientY-rect.top); activeScene?.onPointer('move', pointer); });
canvas.addEventListener('pointerup',e=>{ pointer.down=false; activeScene?.onPointer('up', pointer); });
let actx=null; function ensureAC(){ if(!actx){ try{ actx=new (window.AudioContext||window.webkitAudioContext)(); }catch(e){} } }
function tone(freq, dur=0.12, type='sine', gain=0.05){ ensureAC(); if(!actx) return; const t=actx.currentTime; const o=actx.createOscillator(); const g=actx.createGain(); o.type=type; o.frequency.value=freq; g.gain.value=gain; o.connect(g); g.connect(actx.destination); o.start(t); o.stop(t+dur); }
function fxPositive(){ [523,659,784].forEach((f,i)=> setTimeout(()=>tone(f,0.1,'triangle',0.06), i*110)); }
function fxNegative(){ tone(220,0.15,'sawtooth',0.05); setTimeout(()=>tone(196,0.18,'sawtooth',0.04),120); }
const particles=[]; function emitConfetti(x,y,color='#22c55e',n=18){ for(let i=0;i<n;i++){ particles.push({x,y,vx:(Math.random()-0.5)*6,vy:(Math.random()-1)*6,a:1,c:color}); } }
function updateParticles(){ for(let i=particles.length-1;i>=0;i--){ const p=particles[i]; p.x+=p.vx; p.y+=p.vy; p.vy+=0.12; p.a-=0.02; if(p.a<=0) particles.splice(i,1);} }
function drawParticles(){ particles.forEach(p=>{ ctx.globalAlpha=Math.max(0,p.a); ctx.fillStyle=p.c; rrect(p.x,p.y,5,5,2); ctx.fill(); ctx.globalAlpha=1; }); }
const speakDe = (t, opts = {})=> speak(t, { rate: opts.rate ?? 0.85 });
function speakChunk(chunk){ if (!chunk) return; const lc = chunk.toLowerCase(); const isSingle = chunk.length === 1; const V_LONG = { a:'ah', e:'eh', i:'ih', o:'oh', u:'uh', √§:'√§h', √∂:'√∂h', √º:'√ºh' }; const C_LONG = { m:'m', n:'n', s:'s', l:'l', f:'f', r:'r', z:'z', h:'h' }; let text = isSingle ? (V_LONG[lc] || C_LONG[lc] || lc) : lc; speakDe(text, { rate: 0.75 }); }
const WORDS = [ { id:'du',  text:'du',  syll:[0,1], g:['d','u'],   img:'du', stufe:1 }, { id:'im',  text:'im',  syll:[0,1], g:['i','m'],   img:'im', stufe:1 }, { id:'da',  text:'da',  syll:[0,1], g:['d','a'],   img:'da', stufe:1 }, { id:'oma',   text:'Oma',   syll:[0,1], g:['o','m','a'], img:'oma', stufe:2 }, { id:'opa',   text:'Opa',   syll:[0,1], g:['o','p','a'], img:'opa', stufe:2 }, { id:'mama',  text:'Mama',  syll:[0,2], g:['m','a','m','a'], img:'mama', stufe:2 }, { id:'papa',  text:'Papa',  syll:[0,2], g:['p','a','p','a'], img:'papa', stufe:2 } ];
const PHOTO_URLS = { du: 'https://images.unsplash.com/photo-1532348904171-919f8b2b7e62?q=80&w=1740&auto=format&fit=crop', im: 'https://www.shutterstock.com/image-vector/boy-playing-hide-seek-box-600nw-762258736.jpg', da: 'https://plus.unsplash.com/premium_photo-1729860559950-da4570b34e21?q=80&w=774&auto=format&fit=crop', oma:'https://images.unsplash.com/photo-1577048982771-1960014bde8b?q=80&w=776&auto=format&fit=crop', opa:'https://images.unsplash.com/photo-1586498024141-1940debde48d?q=80&w=774&auto=format&fit=crop', mama:'https://images.unsplash.com/photo-1542385151-efd9000785a0?q=80&w=778&auto=format&fit=crop', papa:'https://images.unsplash.com/photo-1593323925814-253c803de3a5?q=80&w=770&auto=format&fit=crop' };
const IMAGES = {}; function loadImages(){ return new Promise(resolve=>{ let loaded=0; const total=Object.keys(PHOTO_URLS).length; if(total===0) resolve(); const on_load = ()=>{ loaded++; if(loaded===total) resolve(); }; for (const key in PHOTO_URLS){ IMAGES[key]=new Image(); IMAGES[key].crossOrigin='anonymous'; IMAGES[key].onload=on_load; IMAGES[key].onerror=on_load; IMAGES[key].src=PHOTO_URLS[key]; } }); }
function syllChunks(word, starts){ const chunks=[]; for(let i=0;i<starts.length;i++){ const start=starts[i]; const end=(i+1<starts.length? starts[i+1]:word.length); chunks.push(word.slice(start,end)); } return chunks; }
function drawSyllables(x,y, word, starts, colorA='#e6ebf2', colorB='#34d399', font='36px system-ui'){ ctx.save(); const prevFont=ctx.font; ctx.font=font; let cursor=x; for(let i=0;i<starts.length;i++){ const start=starts[i], end=(i+1<starts.length? starts[i+1]: word.length); const chunk=word.slice(start,end); ctx.fillStyle=(i%2===0)?colorA:colorB; ctx.fillText(chunk,cursor,y); cursor += ctx.measureText(chunk).width; } ctx.font=prevFont; ctx.restore(); }
class Scene{ draw(){} onPointer(t,p){} onKey(k){} layout(){} }
class WordLabDetailScene extends Scene{
  constructor(){ super(); this.queue = WORDS.filter(w => w.stufe === 1); this.i = 0; this.tiles=[]; this.slots=[]; this.nextIndex=0; this.deBtn = new Button('Vorlesen','üîä',0,0,180,44,()=> this.speakCurrent()); this.skipBtn = new Button('Weiter','‚û°Ô∏è',0,0,140,44,()=> this.nextWord()); this.layout(); this.prepareWord(); }
  layout(){ const W=canvas.clientWidth/DPR, H=canvas.clientHeight/DPR; this.deBtn.x=20; this.deBtn.y=H-60; this.skipBtn.x=W-160; this.skipBtn.y=H-60; }
  current(){ return this.queue[this.i % this.queue.length]; }
  speakCurrent(){ speakDe(this.current().text); }
  prepareWord(){ this.nextIndex=0; this.tiles=[]; this.slots=[]; const w=this.current(); const chunks=syllChunks(w.text, w.syll); const W=canvas.clientWidth/DPR; const slotW=120, slotH=56, gap=12; const totalW=chunks.length*slotW+(chunks.length-1)*gap; let sx=(W-totalW)/2, sy=canvas.clientHeight/DPR * 0.55; for(let i=0;i<chunks.length;i++){ this.slots.push({x:sx,y:sy,w:slotW,h:slotH,filled:false}); sx+=slotW+gap; } const shuffled=chunks.map((c,idx)=>({chunk:c, idx})).sort(()=>Math.random()-0.5); const bankW=shuffled.length*slotW+(shuffled.length-1)*gap; let bx=(W-bankW)/2, by=sy+100; shuffled.forEach(t=>{ this.tiles.push({x:bx,y:by,w:slotW,h:slotH,chunk:t.chunk,idx:t.idx,chosen:false,hover:false}); bx+=slotW+gap; }); }
  draw(){ const W=canvas.clientWidth/DPR, H=canvas.clientHeight/DPR; ctx.font = '14px system-ui'; ctx.fillStyle = 'var(--ink-dim)'; ctx.fillText("Screen will freeze briefly when sound plays. This is the test.", 10, 20); const cardW=Math.min(640, W*0.7), cardH=Math.min(380,H*0.46); const x=(W-cardW)/2, y=80; shadow(()=>{ ctx.fillStyle='rgba(255,255,255,0.06)'; rrect(x,y,cardW,cardH,26); ctx.fill(); }); const w=this.current(); const img=IMAGES[w.img]; if(img&&img.complete&&img.naturalWidth>0){ const ar=img.naturalWidth/img.naturalHeight; let dw=cardW, dh=dw/ar; if(dh>cardH-40){ dh=cardH-40; dw=dh*ar; } const ix=x+(cardW-dw)/2, iy=y+(cardH-40-dh)/2; ctx.drawImage(img,ix,iy,dw,dh); } const desiredFont='36px system-ui'; const prevFont=ctx.font; ctx.font=desiredFont; const textY=y+cardH+36; const totalWidth=ctx.measureText(w.text).width; drawSyllables((W-totalWidth)/2, textY, w.text, w.syll, '#e6ebf2', '#34d399', desiredFont); ctx.font=prevFont; this.slots.forEach((s,i)=>{ strokeRRect(s.x,s.y,s.w,s.h,14,2,'rgba(255,255,255,0.35)',[8,6]); if(this.nextIndex===i && !s.filled){ ctx.save(); ctx.shadowColor='rgba(16,185,129,0.65)'; ctx.shadowBlur=16; ctx.strokeStyle='rgba(52,211,153,0.9)'; ctx.lineWidth=2; ctx.setLineDash([]); rrect(s.x,s.y,s.w,s.h,14); ctx.stroke(); ctx.restore(); } }); this.tiles.forEach(t=>{ shadow(()=>{ const c1='#334155', c2='#475569'; ctx.fillStyle=gradient(t.x,t.y,t.w,t.h,c1,c2); rrect(t.x,t.y,t.w,t.h,14); ctx.fill(); }); ctx.fillStyle=t.chosen ? '#c7f9e9' : '#e6ebf2'; ctx.font='30px system-ui'; const tw=ctx.measureText(t.chunk).width; ctx.fillText(t.chunk, t.x+(t.w-tw)/2, t.y+t.h/2+7); }); this.deBtn.hover=this.deBtn.contains(pointer.x,pointer.y); this.deBtn.draw(); this.skipBtn.hover=this.skipBtn.contains(pointer.x,pointer.y); this.skipBtn.draw(); }
  onPointer(type,p){ if(type!=='down') return; if(this.deBtn.contains(p.x,p.y))   { this.deBtn.onClick(); return; } if(this.skipBtn.contains(p.x,p.y)) { this.skipBtn.onClick(); return; } const hit=this.tiles.find(t=> p.x>=t.x && p.x<=t.x+t.w && p.y>=t.y && p.y<=t.y+t.h && !t.chosen); if(hit){ speakChunk(hit.chunk); if(hit.idx===this.nextIndex){ const slot=this.slots[this.nextIndex]; hit.x=slot.x; hit.y=slot.y; hit.chosen=true; slot.filled=true; this.nextIndex++; fxPositive(); emitConfetti(hit.x+hit.w/2, hit.y, '#34d399', 22); if(this.nextIndex>=this.slots.length){ speakDe(this.current().text); setTimeout(()=>{ this.nextWord(); }, 500); } } else { fxNegative(); } } }
  nextWord(){ this.i = (this.i+1) % this.queue.length; this.prepareWord(); }
}

/* ---------- App Loop & Start ---------- */
function loop(){
  ctx.clearRect(0,0,canvas.clientWidth,canvas.clientHeight);
  activeScene?.draw?.();
  updateParticles(); 
  drawParticles();
  animationFrameId = requestAnimationFrame(loop);
}
async function start(){
  ctx.fillStyle = '#e0e0e0'; ctx.font = '24px system-ui'; const msg = 'Loading...';
  ctx.fillText(msg, (window.innerWidth - ctx.measureText(msg).width)/2, window.innerHeight/2);
  
  await Promise.all([loadImages(), initializeSpeech()]);
  
  resize();
  activeScene = new WordLabDetailScene();
  animationFrameId = requestAnimationFrame(loop);
}
start();

</script>
</body>
</html>